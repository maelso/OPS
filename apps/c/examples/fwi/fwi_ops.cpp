//
// auto-generated by ops.py
//
#define _POSIX_C_SOURCE 200809L
#define OPS_2D
void ops_init_backend();
#include "stdlib.h"
#include "math.h"
#include "sys/time.h"
#include  "ops_lib_cpp.h"

//
// ops_par_loop declarations
//

void ops_par_loop_Kernel0(char const *, ops_block, int , int*,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg );



#include "fwi.h"

struct dataobj
{
  void * data;
  int * size;
  int * npsize;
  int * dsize;
  int * hsize;
  int * hofs;
  int * oofs;
} ;

struct profiler
{
  double section0;
  double section1;
  double section2;
} ;

int Forward(const float dt, struct dataobj * m_vec, const float o_x, const float o_y, struct dataobj * rec_vec, struct dataobj * rec_coords_vec, struct dataobj * src_vec, struct dataobj * src_coords_vec, struct dataobj * u_vec, const int x_M, const int x_m, const int y_M, const int y_m, struct dataobj * damp_vec, const int p_rec_M, const int p_rec_m, const int p_src_M, const int p_src_m, const int time_M, const int time_m, struct profiler * timers)
{
  float (* m)[m_vec->size[1]] __attribute__ ((aligned (64))) = (float (*)[m_vec->size[1]]) m_vec->data;
  float (* rec)[rec_vec->size[1]] __attribute__ ((aligned (64))) = (float (*)[rec_vec->size[1]]) rec_vec->data;
  float (* rec_coords)[rec_coords_vec->size[1]] __attribute__ ((aligned (64))) = (float (*)[rec_coords_vec->size[1]]) rec_coords_vec->data;
  float (* src)[src_vec->size[1]] __attribute__ ((aligned (64))) = (float (*)[src_vec->size[1]]) src_vec->data;
  float (* src_coords)[src_coords_vec->size[1]] __attribute__ ((aligned (64))) = (float (*)[src_coords_vec->size[1]]) src_coords_vec->data;
  float (* u)[u_vec->size[1]][u_vec->size[2]] __attribute__ ((aligned (64))) = (float (*)[u_vec->size[1]][u_vec->size[2]]) u_vec->data;
  float (* damp)[damp_vec->size[1]] __attribute__ ((aligned (64))) = (float (*)[damp_vec->size[1]]) damp_vec->data;
  ops_init(0,0,2);
  ops_init_backend();
  int range_0[4] = {x_m, x_M, y_m, y_M};
  ops_block block_0 = ops_decl_block(2,"block_0");
  int s2d_ut0_9pt[18] = {0, -1, 0, -2, -2, 0, 0, 0, 0, 2, 0, 1, 1, 0, 2, 0, -1, 0};
  ops_stencil S2D_UT0_9PT = ops_decl_stencil(2,9,(int *)s2d_ut0_9pt,"S2D_UT0_9PT");
  int s2d_ut2_1pt[2] = {0, 0};
  ops_stencil S2D_UT2_1PT = ops_decl_stencil(2,1,(int *)s2d_ut2_1pt,"S2D_UT2_1PT");
  int s2d_ut1_1pt[2] = {0, 0};
  ops_stencil S2D_UT1_1PT = ops_decl_stencil(2,1,(int *)s2d_ut1_1pt,"S2D_UT1_1PT");
  int s2d_m_1pt[2] = {0, 0};
  ops_stencil S2D_M_1PT = ops_decl_stencil(2,1,(int *)s2d_m_1pt,"S2D_M_1PT");
  int s2d_damp_1pt[2] = {0, 0};
  ops_stencil S2D_DAMP_1PT = ops_decl_stencil(2,1,(int *)s2d_damp_1pt,"S2D_DAMP_1PT");
  int damp_dim[2] = {181, 181};
  int damp_base[2] = {0, 0};
  int damp_d_p[2] = {1, 1};
  int damp_d_m[2] = {-1, -1};
  ops_dat damp_dat = ops_decl_dat(block_0,1,(int *)damp_dim,(int *)damp_base,(int *)damp_d_m,(int *)damp_d_p,(float *)&damp[0],"float","damp");
  int m_dim[2] = {181, 181};
  int m_base[2] = {0, 0};
  int m_d_p[2] = {2, 2};
  int m_d_m[2] = {-2, -2};
  ops_dat m_dat = ops_decl_dat(block_0,1,(int *)m_dim,(int *)m_base,(int *)m_d_m,(int *)m_d_p,(float *)&m[0],"float","m");
  int u_dim[2] = {181, 181};
  int u_base[2] = {0, 0};
  int u_d_p[2] = {4, 4};
  int u_d_m[2] = {-4, -4};
  ops_dat u_dat[3];
  u_dat[0] = ops_decl_dat(block_0,1,(int *)u_dim,(int *)u_base,(int *)u_d_m,(int *)u_d_p,(float *)&u[0],"float","ut0");
  u_dat[1] = ops_decl_dat(block_0,1,(int *)u_dim,(int *)u_base,(int *)u_d_m,(int *)u_d_p,(float *)&u[1],"float","ut1");
  u_dat[2] = ops_decl_dat(block_0,1,(int *)u_dim,(int *)u_base,(int *)u_d_m,(int *)u_d_p,(float *)&u[2],"float","ut2");
  ops_partition("");
  for (int time = time_m, t0 = (time)%(3), t1 = (time + 1)%(3), t2 = (time + 2)%(3); time <= time_M; time += 1, t0 = (time)%(3), t1 = (time + 1)%(3), t2 = (time + 2)%(3))
  {
    struct timeval start_section0, end_section0;
    gettimeofday(&start_section0, NULL);

    ops_par_loop_Kernel0("Kernel0", block_0, 2, (int *)range_0,
                 ops_arg_dat(damp_dat, 1, S2D_DAMP_1PT, "float", OPS_READ),
                 ops_arg_dat(m_dat, 1, S2D_M_1PT, "float", OPS_READ),
                 ops_arg_dat(u_dat[t0], 1, S2D_UT0_9PT, "float", OPS_READ),
                 ops_arg_dat(u_dat[t1], 1, S2D_UT1_1PT, "float", OPS_WRITE),
                 ops_arg_dat(u_dat[t2], 1, S2D_UT2_1PT, "float", OPS_READ),
                 ops_arg_gbl(&dt, 1, "float", OPS_READ));

    gettimeofday(&end_section0, NULL);
    timers->section0 += (double)(end_section0.tv_sec-start_section0.tv_sec)+(double)(end_section0.tv_usec-start_section0.tv_usec)/1000000;
    struct timeval start_section1, end_section1;
    gettimeofday(&start_section1, NULL);

    for (int p_src = p_src_m; p_src <= p_src_M; p_src += 1)
    {
      float r1 = (int)(floor(-1.0e-1F*o_x + 1.0e-1F*src_coords[p_src][0]));
      int ii_src_0 = r1;
      float r2 = (int)(floor(-1.0e-1F*o_y + 1.0e-1F*src_coords[p_src][1]));
      int ii_src_1 = r2;
      int ii_src_2 = r2 + 1;
      int ii_src_3 = r1 + 1;
      float px = (float)(-1.0e+1F*r1 - o_x + src_coords[p_src][0]);
      float py = (float)(-1.0e+1F*r2 - o_y + src_coords[p_src][1]);
      if (ii_src_0 >= x_m - 1 && ii_src_1 >= y_m - 1 && ii_src_0 <= x_M + 1 && ii_src_1 <= y_M + 1)
      {
        float r3 = (dt*dt)*(1.0e-2F*px*py - 1.0e-1F*px - 1.0e-1F*py + 1)*src[time][p_src]/m[ii_src_0][ii_src_1];
        u[t1][ii_src_0][ii_src_1] += r3;
      }
      if (ii_src_0 >= x_m - 1 && ii_src_2 >= y_m - 1 && ii_src_0 <= x_M + 1 && ii_src_2 <= y_M + 1)
      {
        float r4 = (dt*dt)*(-1.0e-2F*px*py + 1.0e-1F*py)*src[time][p_src]/m[ii_src_0][ii_src_2];
        u[t1][ii_src_0][ii_src_2] += r4;
      }
      if (ii_src_1 >= y_m - 1 && ii_src_3 >= x_m - 1 && ii_src_1 <= y_M + 1 && ii_src_3 <= x_M + 1)
      {
        float r5 = (dt*dt)*(-1.0e-2F*px*py + 1.0e-1F*px)*src[time][p_src]/m[ii_src_3][ii_src_1];
        u[t1][ii_src_3][ii_src_1] += r5;
      }
      if (ii_src_2 >= y_m - 1 && ii_src_3 >= x_m - 1 && ii_src_2 <= y_M + 1 && ii_src_3 <= x_M + 1)
      {
        float r6 = 1.0e-2F*px*py*(dt*dt)*src[time][p_src]/m[ii_src_3][ii_src_2];
        u[t1][ii_src_3][ii_src_2] += r6;
      }
    }

    gettimeofday(&end_section1, NULL);
    timers->section1 += (double)(end_section1.tv_sec-start_section1.tv_sec)+(double)(end_section1.tv_usec-start_section1.tv_usec)/1000000;
    struct timeval start_section2, end_section2;
    gettimeofday(&start_section2, NULL);

    for (int p_rec = p_rec_m; p_rec <= p_rec_M; p_rec += 1)
    {
      float r7 = (int)(floor(-1.0e-1F*o_x + 1.0e-1F*rec_coords[p_rec][0]));
      int ii_rec_0 = r7;
      float r8 = (int)(floor(-1.0e-1F*o_y + 1.0e-1F*rec_coords[p_rec][1]));
      int ii_rec_1 = r8;
      int ii_rec_2 = r8 + 1;
      int ii_rec_3 = r7 + 1;
      float px = (float)(-1.0e+1F*r7 - o_x + rec_coords[p_rec][0]);
      float py = (float)(-1.0e+1F*r8 - o_y + rec_coords[p_rec][1]);
      float sum = 0.0F;
      if (ii_rec_0 >= x_m - 1 && ii_rec_1 >= y_m - 1 && ii_rec_0 <= x_M + 1 && ii_rec_1 <= y_M + 1)
      {
        sum += (1.0e-2F*px*py - 1.0e-1F*px - 1.0e-1F*py + 1)*u[t0][ii_rec_0][ii_rec_1];
      }
      if (ii_rec_0 >= x_m - 1 && ii_rec_2 >= y_m - 1 && ii_rec_0 <= x_M + 1 && ii_rec_2 <= y_M + 1)
      {
        sum += (-1.0e-2F*px*py + 1.0e-1F*py)*u[t0][ii_rec_0][ii_rec_2];
      }
      if (ii_rec_1 >= y_m - 1 && ii_rec_3 >= x_m - 1 && ii_rec_1 <= y_M + 1 && ii_rec_3 <= x_M + 1)
      {
        sum += (-1.0e-2F*px*py + 1.0e-1F*px)*u[t0][ii_rec_3][ii_rec_1];
      }
      if (ii_rec_2 >= y_m - 1 && ii_rec_3 >= x_m - 1 && ii_rec_2 <= y_M + 1 && ii_rec_3 <= x_M + 1)
      {
        sum += 1.0e-2F*px*py*u[t0][ii_rec_3][ii_rec_2];
      }
      rec[time][p_rec] = sum;
    }

    gettimeofday(&end_section2, NULL);
    timers->section2 += (double)(end_section2.tv_sec-start_section2.tv_sec)+(double)(end_section2.tv_usec-start_section2.tv_usec)/1000000;
  }
  ops_timing_output(stdout);
  ops_exit();
  return 0;
}